}
# 3. Lógica principal con la clave identificada
if (!is.null(culprit_key)) {
current_config <- isolate(rv_map_params[[culprit_key]])
# Usar la clave dinámica aquí
showModal(config_modal(culprit_key, current_config$name, current_config$color))
# Actualizar los inputs del modal dinámicamente
colourpicker::updateColourInput(session, paste0("modal_", culprit_key, "_col"), value = current_config$color)
updateSliderInput(session, paste0("modal_", culprit_key, "_size"), value = current_config$size)
}
}, ignoreInit = TRUE)
observeEvent({
# Escucha a todos los botones Save
sapply(ALL_SAVE_BUTTONS, function(id) input[[id]])
}, {
culprit_key <- NULL
# 1. Identificar qué botón Save fue presionado
for (layer_key in ALL_BUTTON_KEYS) {
# 🚨 CORRECCIÓN 1: Definir el ID correcto del botón de Guardar
save_btn_id <- paste0("modal_", layer_key, "_save")
# 🚨 CORRECCIÓN 2: Usar ifelse para manejar el valor NULL inicial
# Si input[[ID]] es NULL, asumimos que el contador es 0 (no se ha presionado).
current_save_count <- ifelse(is.null(input[[save_btn_id]]),
0,
input[[save_btn_id]])
previous_save_count <- isolate(rv_save_state[[save_btn_id]])
# Ahora la comparación funciona, ya que current_save_count es 0, no NULL.
if (current_save_count > previous_save_count) {
culprit_key <- layer_key
# Actualizamos el estado anterior con el valor que DISPARÓ el evento.
rv_save_state[[save_btn_id]] <- current_save_count
break
}
}
# 2. Ejecutar la lógica de guardar si se encontró al culpable
if (!is.null(culprit_key)) {
modal_col_id <- paste0("modal_", culprit_key, "_col")
modal_size_id <- paste0("modal_", culprit_key, "_size")
# Es seguro acceder a estos inputs ya que el modal estaba abierto
# (y por lo tanto estos inputs deben tener valores)
rv_map_params[[culprit_key]]$color <- input[[modal_col_id]]
rv_map_params[[culprit_key]]$size <- input[[modal_size_id]]
removeModal()
##Y actualizamos el leafletproxy. No hay que usar más informacion, solo borramos la capa, y la agregamos con el nuevo color
#culprit_key
group=find_parent_input_id(culprit_key)
#Removegroup
proxy = leafletProxy("mapa_principal", session)
proxy |>  clearGroup(group = culprit_key)
#Agregamos grupo
data_para_agregar=rv_config$CAPA_CONFIG_DATA[[culprit_key]]$data
geom_type <- as.character(unique(st_geometry_type(data_para_agregar)))[1]
if (geom_type %in% c("POLYGON", "MULTIPOLYGON")) {
proxy |> addPolygons(data = data_para_agregar, fillColor =input[[modal_col_id]], color = "white", weight = 1, fillOpacity = 0.4, group = layer_key)
} else if (geom_type %in% c("LINESTRING", "MULTILINESTRING")) {
proxy |> addPolylines(data = data_para_agregar, color = input[[modal_col_id]], weight = 3, opacity = 0.8, group = layer_key)
} else if (geom_type %in% c("POINT", "MULTIPOINT")) {
proxy |> addCircleMarkers(data = data_para_agregar, radius = 6, color = input[[modal_col_id]], fillOpacity = 0.9, group = layer_key)
}
}
}, ignoreInit = TRUE)
observe({
current_layers <- selected_layers_vector()
previous_layers <- v$selected
proxy = leafletProxy("mapa_principal", session)
layers_to_add = setdiff(current_layers, previous_layers)
layers_to_remove = setdiff(previous_layers, current_layers)
print(layers_to_remove)
for (layer_key in layers_to_remove) {
proxy |>  clearGroup(group = layer_key)
}
successful_layers = setdiff(previous_layers, layers_to_remove)
for (layer_key in layers_to_add) {
#print(rv_config$CAPA_CONFIG_DATA[[layer_key]])
config <- rv_config$CAPA_CONFIG_DATA[[layer_key]]
if (is.null(config)) next
tryCatch({
#load_layer_data(layer_key)
if (rv_config$CAPA_CONFIG_DATA[[layer_key]]$data |> is.null()) {
print("Se lee desde el buig")
data_sf <- load_layer_data(buig = buig,
nombre_buig =  config$nombre_buig,
columnas_interes = config$cols,
custom_filter = ifelse(config$custom_filter |> is.null(),'',config$custom_filter))###Aqui se ve a cambiar por la función custom de dplyr.
rv_config$CAPA_CONFIG_DATA[[layer_key]]$data <- data_sf
} else {
print("Se lee desde local ")
data_sf <- rv_config$CAPA_CONFIG_DATA[[layer_key]]$data
}
geom_type <- as.character(unique(st_geometry_type(data_sf)))[1]
if (geom_type %in% c("POLYGON", "MULTIPOLYGON")) {
proxy |> addPolygons(data = data_sf, fillColor = "#66A3D2", color = "white", weight = 1, fillOpacity = 0.4, group = layer_key)
} else if (geom_type %in% c("LINESTRING", "MULTILINESTRING")) {
proxy |> addPolylines(data = data_sf, color = "black", weight = 3, opacity = 0.8, group = layer_key)
} else if (geom_type %in% c("POINT", "MULTIPOINT")) {
proxy |> addCircleMarkers(data = data_sf, radius = 6, color = "red", fillOpacity = 0.9, group = layer_key)
}
successful_layers <- c(successful_layers, layer_key)
}, error = function(e) {
print(paste("ERROR:", e$message))
showNotification(
ui = HTML(paste("<strong>Error de Carga:</strong> No se pudo cargar la capa <b>", config$nombre_buig, "</b>.",
"Por favor, verifique la conexión o el nombre de la tabla. ")),
type = "error",
duration = 2
)
parent_input_id <- find_parent_input_id(layer_key)
if (!is.null(parent_input_id)) {
current_selection_in_group <- input[[parent_input_id]]
new_selection <- current_selection_in_group[current_selection_in_group != layer_key]
updateCheckboxGroupInput(session, parent_input_id, selected = new_selection)
}
})
}
v$selected <- successful_layers %>% unique()
}) # Fin del observe
}
shinyApp(ui, server)
rsconnect::writeManifest()
rsconnect::writeManifest("../app.R")
rsconnect::writeManifest("../")
library(sf)
source("../../../Reutilizables/Postgres_BUIG/conexion_buig.R")
st_read(buig,"hospitales_hgo")->hhgo
View(hhgo)
hhgo st_read("../Inputs/hospitales_hgo.geojson")
hhgo= st_read("../Inputs/hospitales_hgo.geojson")
hhgo |> dplyr::filter(grepl(pattern = "Regional",name))
hhgo |> dplyr::filter(grepl(pattern = "Regional",name)) |> st_write("../Inputs/hospitales_hgo_reg.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(!grepl(pattern = "Regional",name)) |> st_write("../Inputs/hospitales_hgo_gral.geojson",driver = "GeoJSON")
hhgo= st_read("../Inputs/red_carretera_sipdus.geojson")
hhgo |> dplyr::filter(administra=='Federal') |> st_write("../Inputs/red_carretera_sipdus_fed.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(administra=='Federal') |> st_write("../Inputs/red_carretera_sipdus_federal.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(administra=='Estatal') |> st_write("../Inputs/red_carretera_sipdus_estatal.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(administra=='Municipal') |> st_write("../Inputs/red_carretera_sipdus_municipal.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(grepl(pattern = "Regional",name)) |> st_zm() |> st_write("../Inputs/hospitales_hgo_reg.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(!grepl(pattern = "Regional",name))|> st_zm()  |> st_write("../Inputs/hospitales_hgo_gral.geojson",driver = "GeoJSON")
library(sf)
hhgo= st_read("../Inputs/hospitales_hgo.geojson")
hhgo |> dplyr::filter(grepl(pattern = "Regional",name)) |> st_zm() |> st_write("../Inputs/hospitales_hgo_reg.geojson",driver = "GeoJSON")
hhgo |> dplyr::filter(!grepl(pattern = "Regional",name))|> st_zm()  |> st_write("../Inputs/hospitales_hgo_gral.geojson",driver = "GeoJSON")
hhgo= st_read("../Inputs/red_carretera_sipdus.geojson")
st_read("../Inputs/zonificacion_de_vulnerabilidad_y_areas_susceptibles_a_hundimien.geojson")
library(leaflet)
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/zonificacion_de_vulnerabilidad_y_areas_susceptibles_a_hundimien.geojson"))
shiny::runApp(appDir = "../")
popup_general = function(datos_sf = datos_sf) {
columnas = names(datos_sf)
columnas = columnas[columnas != "geom"]
columnas = columnas[columnas != "geometry"]
popup = apply(
sf::st_drop_geometry(datos_sf)[, columnas],
1,
function(fila) {
campos =  paste0("<b>", columnas, ":</b> ", fila, collapse = "<br>")
htmltools::HTML(campos)
}
)
return(popup)
}
popup_general( datos_sf = st_read("../Inputs/zonificacion_de_vulnerabilidad_y_areas_susceptibles_a_hundimien.geojson"))
names(st_read("../Inputs/zonificacion_de_vulnerabilidad_y_areas_susceptibles_a_hundimien.geojson"))
colsss=names(st_read("../Inputs/zonificacion_de_vulnerabilidad_y_areas_susceptibles_a_hundimien.geojson"))
colsss[colsss='geometry']
colsss
colsss[colsss!='geometry']
shiny::runApp(appDir = "../")
popup_general(st_read("../Inputs/limite_municipal_simple.geojson"))
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/limite_municipal_simple.geojson"),popup = popup_general(st_read("../Inputs/limite_municipal_simple.geojson")))
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/limite_municipal_simple.geojson"),popup = popup_general(st_read("../Inputs/limite_municipal_simple.geojson")) |> unlist())
popup_general(st_read("../Inputs/limite_municipal_simple.geojson")) |> unlist()
popup_general(st_read("../Inputs/limite_municipal_simple.geojson")) |> as.character()
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/limite_municipal_simple.geojson"),popup = popup_general(st_read("../Inputs/limite_municipal_simple.geojson")) |> as.character())
shiny::runApp(appDir = "../")
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"))
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),popup = popup_general(st_read("../Inputs/hospitales_hgo_gral.geojson")) |> as.character())
st_read("../Inputs/hospitales_hgo_gral.geojson")
st_read("../Inputs/hospitales_hgo_gral.geojson")$geometry
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_reg.geojson"))
shiny::runApp(appDir = "../")
shiny::runApp(appDir = "../")
st_read("../Inputs/regiones_simple.geojson")
st_read("../Inputs/regiones_simple.geojson") |> colnames()
shiny::runApp(appDir = "../")
popup_general = function(datos_sf = datos_sf) {
columnas = names(datos_sf)
columnas = columnas[columnas != "geom"]
columnas = columnas[columnas != "geometry"]
popup = apply(
sf::st_drop_geometry(datos_sf)[, columnas, drop = FALSE],
1,
function(fila) {
campos =  paste0("<b>", columnas, ":</b> ", fila, collapse = "<br>")
htmltools::HTML(campos)
}
)
return(popup)
}
shiny::runApp(appDir = "../")
popup_general = function(datos_sf = datos_sf) {
columnas = names(datos_sf)
# Filtramos columnas de geometría
columnas = columnas[columnas != "geom"]
columnas = columnas[columnas != "geometry"]
# 🚨 ROBUSTEZ: Manejar el caso donde no quedan columnas de datos
if (length(columnas) == 0) {
# Si no hay datos para mostrar, devolvemos un mensaje por defecto
# El número de repeticiones debe coincidir con el número de filas en datos_sf
return(rep(htmltools::HTML("<b>Sin datos disponibles</b>"), nrow(datos_sf)))
}
popup = apply(
# 🚨 CORRECCIÓN CLAVE: Usar drop = FALSE para mantener la estructura de data frame
sf::st_drop_geometry(datos_sf)[, columnas, drop = FALSE],
1, # Aplicar por fila
function(fila) {
# Nota: 'fila' será un vector, incluso si solo hay una columna
campos =  paste0("<b>", columnas, ":</b> ", fila, collapse = "<br>")
return(htmltools::HTML(campos))
}
)
return(popup)
}
shiny::runApp(appDir = "../")
shiny::runApp(appDir = "../")
shiny::runApp(appDir = "../")
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/peligro_por_caida_de_bloques.geojson"))
st_read("../Inputs/peligro_por_caida_de_bloques.geojson") |> st_geometry() |> st_geometry_type()
st_read("../Inputs/peligro_por_caida_de_bloques.geojson") |> st_geometry() |> st_geometry_type() |> table()
st_read("../Inputs/peligro_por_caida_de_bloques.geojson") |> dplyr::filter(st_geometry_type(geometry)=='GEOMETRYCOLLECTION')
st_read("../Inputs/peligro_por_caida_de_bloques.geojson") |> dplyr::filter(st_is_empty(geometry))
shiny::runApp(appDir = "../")
st_read("../Inputs/Estructuras_elevadas.geojson")
st_read("../Inputs/Estructuras_elevadas.geojson") |> st_set_crs(st_crs("EPSG:32614"))
st_read("../Inputs/Estructuras_elevadas.geojson") |> st_set_crs(st_crs("EPSG:32614")) |> st_transform(st_crs("EPSG:4326"))
st_read("../Inputs/Estructuras_elevadas.geojson") |> st_set_crs(st_crs("EPSG:32614")) |> st_transform(st_crs("EPSG:4326")) |> st_write("../Inputs/estructuras_elevadas.geojson",driver='GeoJSON')
st_read("../Inputs/Estructuras_elevadas.geojson") |> st_set_crs(st_crs("EPSG:32614")) |> st_transform(st_crs("EPSG:4326")) |> st_write("../Inputs/estructuras_elevadas_4326.geojson",driver='GeoJSON')
st_read("../Inputs/estructuras_elevadas_4326.geojson") |> st_set_crs(st_crs("EPSG:32614")) |> st_transform(st_crs("EPSG:4326")) |> st_write("../Inputs/Estructuras_elevadas.geojson",driver='GeoJSON')
st_read("../Inputs/estructuras_elevadas_4326.geojson") |> st_set_crs(st_crs("EPSG:32614")) |> st_transform(st_crs("EPSG:4326"))
st_read("../Inputs/estructuras_elevadas_4326.geojson") |> st_write("../Inputs/Estructuras_elevadas.geojson",driver='GeoJSON')
shiny::runApp(appDir = "../")
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/peligro_por_caida_de_bloques.geojson"),weight = 15)
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),weight = 15)
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),stroke = 15)
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/red_carretera_sipdus_federal.geojson"))
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),weight = 15)
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/red_carretera_sipdus_federal.geojson"),weight = 15)
shiny::runApp(appDir = "../")
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),weight = 15) |> fitBounds()
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),weight = 15) |> fitBounds(st_bbox(st_read("../Inputs/hospitales_hgo_gral.geojson")) |> as.character())
leaflet() |> addTiles() |> addPolygons(data=st_read("../Inputs/hospitales_hgo_gral.geojson"),weight = 15) |> fitBounds(st_bbox(st_read("../Inputs/hospitales_hgo_gral.geojson")) |> as.character() |> unlist())
shiny::runApp(appDir = "../")
library(sf)
st_read("../Inputs/puentes_hgo.geojson")
st_read("../Inputs/estructuras_viales.geojson") |> st_geometry() |> plot()
shiny::runApp(appDir = "../")
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'citnovaconsulta',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
View(Lista_BUIG)
DBI::dbDisconnect(buig)
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
View(Lista_BUIG)
Lista_BUIG[[35]]
st_read(buig,'Municipios_afectados_corte15oct25')
shiny::runApp(appDir = "../")
DBI::dbDisconnect(buig)
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
View(Lista_BUIG)
View(Lista_BUIG)
Lista_BUIG[[49]]
##Del buig, pozos_estado_de_hidalgo
st_read(buig,"Pozos_de_Estado_de_Hidalgo")
##Del buig, pozos_estado_de_hidalgo
st_read(buig,"Pozos_de_Estado_de_Hidalgo") |> dplyr::select(nombre,tipo) |> st_write("../Inputs/Pozos_de_Estado_de_Hidalgo.geojson",driver='GeoJSON')
st_read("../Inputs/loc_urb_simple.geojson")
st_read("../Inputs/loc_urb_simple.geojson")$pob1
st_read("../Inputs/loc_urb_simple.geojson")$pob1 |> sum()
st_read("../Inputs/loc_rur_simple.geojson")$pob1 |> sum()
rbind(st_read("../Inputs/loc_rur_simple.geojson"),st_read("../Inputs/loc_urb_simple.geojson"))
base_pob_default=rbind(st_read("../Inputs/loc_rur_simple.geojson"),st_read("../Inputs/loc_urb_simple.geojson"))
ui=shiny::flowLayout(
leafletOutput("mapa_principal", height = "95vh",width = "95vw")
)
Calcular_Interseccion=function(poligono,base_pob){
#poligono debe ser un sf de una sola entrada tipo POLYGON
#base_pob debe ser un sf que tenga una variable numerica de población llamada "POB"
base_pob$Area_Original=as.numeric(st_area(x = st_transform(base_pob,crs=32614)))
Interseccion=st_intersection(x = base_pob,y = poligono)
Interseccion$Area_Nueva=as.numeric(st_area(x = st_transform(Interseccion,crs=32614)))
Interseccion$POB_Proporcional=(Interseccion$Area_Nueva*Interseccion$POB)/Interseccion$Area_Original
return(Interseccion)
}
server = function(input, output, session) {
output$mapa_principal <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(lng = -98, lat = 20, zoom = 6) |>
addLayersControl(
options = layersControlOptions(collapsed = FALSE)
) |>
addDrawToolbar()
})
observeEvent(input$mapa_principal_draw_new_feature, {
print("El usuario hizo un dibujito")
Cordenadas <- input$mapa_principal_draw_new_feature$geometry$coordinates[[1]]
print(Cordenadas)
n=length(Cordenadas)
Aux=data.frame(matrix(ncol = 2,nrow = n))
for(i in 1:n){
Aux[i,1]=Cordenadas[[i]][[1]]
Aux[i,2]=Cordenadas[[i]][[2]]
}
Aux2=st_as_sf(Aux, coords = c("X1", "X2"), crs = 4326)
Poligono=sf::st_as_sf(st_cast(st_combine(Aux2),"POLYGON"))
Area_Delimitada=Calcular_Interseccion(poligono = Poligono,base_pob = MUNS) #Puedes cambiar MUNS
print(Area_Delimitada$POB_Proporcional)
})
}
Calcular_Interseccion=function(poligono,base_pob){
#poligono debe ser un sf de una sola entrada tipo POLYGON
#base_pob debe ser un sf que tenga una variable numerica de población llamada "POB"
base_pob$Area_Original=as.numeric(st_area(x = st_transform(base_pob,crs=32614)))
Interseccion=st_intersection(x = base_pob,y = poligono)
Interseccion$Area_Nueva=as.numeric(st_area(x = st_transform(Interseccion,crs=32614)))
Interseccion$POB_Proporcional=(Interseccion$Area_Nueva*Interseccion$pob1)/Interseccion$Area_Original
return(Interseccion)
}
server = function(input, output, session) {
output$mapa_principal <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(lng = -98, lat = 20, zoom = 6) |>
addLayersControl(
options = layersControlOptions(collapsed = FALSE)
) |>
addDrawToolbar()
})
observeEvent(input$mapa_principal_draw_new_feature, {
print("El usuario hizo un dibujito")
Cordenadas <- input$mapa_principal_draw_new_feature$geometry$coordinates[[1]]
print(Cordenadas)
n=length(Cordenadas)
Aux=data.frame(matrix(ncol = 2,nrow = n))
for(i in 1:n){
Aux[i,1]=Cordenadas[[i]][[1]]
Aux[i,2]=Cordenadas[[i]][[2]]
}
Aux2=st_as_sf(Aux, coords = c("X1", "X2"), crs = 4326)
Poligono=sf::st_as_sf(st_cast(st_combine(Aux2),"POLYGON"))
Area_Delimitada=Calcular_Interseccion(poligono = Poligono,base_pob = base_pob_default) #Puedes cambiar MUNS
print(Area_Delimitada$POB_Proporcional)
})
}
shinyApp(ui, server)
library(leaflet)
library(leaflet.extras)
library(shiny)
ui=shiny::flowLayout(
leafletOutput("mapa_principal", height = "95vh",width = "95vw")
)
base_pob_default=rbind(st_read("../Inputs/loc_rur_simple.geojson"),st_read("../Inputs/loc_urb_simple.geojson"))
Calcular_Interseccion=function(poligono,base_pob){
#poligono debe ser un sf de una sola entrada tipo POLYGON
#base_pob debe ser un sf que tenga una variable numerica de población llamada "POB"
base_pob$Area_Original=as.numeric(st_area(x = st_transform(base_pob,crs=32614)))
Interseccion=st_intersection(x = base_pob,y = poligono)
Interseccion$Area_Nueva=as.numeric(st_area(x = st_transform(Interseccion,crs=32614)))
Interseccion$POB_Proporcional=(Interseccion$Area_Nueva*Interseccion$pob1)/Interseccion$Area_Original
return(Interseccion)
}
server = function(input, output, session) {
output$mapa_principal <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(lng = -98, lat = 20, zoom = 6) |>
addLayersControl(
options = layersControlOptions(collapsed = FALSE)
) |>
addDrawToolbar()
})
observeEvent(input$mapa_principal_draw_new_feature, {
print("El usuario hizo un dibujito")
Cordenadas <- input$mapa_principal_draw_new_feature$geometry$coordinates[[1]]
print(Cordenadas)
n=length(Cordenadas)
Aux=data.frame(matrix(ncol = 2,nrow = n))
for(i in 1:n){
Aux[i,1]=Cordenadas[[i]][[1]]
Aux[i,2]=Cordenadas[[i]][[2]]
}
Aux2=st_as_sf(Aux, coords = c("X1", "X2"), crs = 4326)
Poligono=sf::st_as_sf(st_cast(st_combine(Aux2),"POLYGON"))
Area_Delimitada=Calcular_Interseccion(poligono = Poligono,base_pob = base_pob_default) #Puedes cambiar MUNS
print(Area_Delimitada$POB_Proporcional)
})
}
shinyApp(ui, server)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
View(Lista_BUIG)
st_read(buig,Lista_BUIG[[45]])
st_read(buig,Lista_BUIG[[45]])
st_read(buig,Lista_BUIG[[45]])
st_read(buig,Lista_BUIG[[45]])
DBI::dbDisconnect(buig)
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
st_read(buig,Lista_BUIG[[45]])
View(Lista_BUIG)
Lista_BUIG[[45]]
st_read(buig,Lista_BUIG[[45]])
st_read(buig,Lista_BUIG[[45]])
DBI::dbDisconnect(buig)
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
st_read(buig,Lista_BUIG[[45]])
DBI::dbDisconnect(buig)
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
Lista_BUIG=DBI::dbListTables(buig) |> as.list()
st_read(buig,Lista_BUIG[[45]])
st_read(buig,Lista_BUIG[[45]])$total |> hist()
st_read(buig,Lista_BUIG[[45]])$total |> round(2) |> table()
st_read(buig,Lista_BUIG[[45]])$total |> round(2) |> table() |> sum()
##Escuelas de prioridad
escuelas_en_riesgo=st_read(buig,Lista_BUIG[[45]])
escuelas_en_riesgo$total>mean(escuelas_en_riesgo$total) |> sum()
(escuelas_en_riesgo$total>mean(escuelas_en_riesgo$total)) |> sum()
(escuelas_en_riesgo$total>=mean(escuelas_en_riesgo$total)) |> sum()
Lista_BUIG[[45]]
escuelas_en_riesgo=escuelas_en_riesgo |>
dplyr::filter(total>mean(total)) |> dplyr::select(claveseph,Nombre_d_1,LOCALIDAD,MUNICIPIO,total,geom) |>
dplyr::rename(riesgo_prioridad=total) |> st_write("../Inputs/PRIORIDAD_ESCUELAS.geojson",driver = "GeoJSON")
escuelas_en_riesgo |>
dplyr::filter(total>mean(total)) |> dplyr::select(claveseph,Nombre_d_1,LOCALIDAD,MUNICIPIO,total,geom) |>
dplyr::rename(riesgo_prioridad=total) |> st_zm()
##Escuelas de prioridad
escuelas_en_riesgo=st_read(buig,Lista_BUIG[[45]])
escuelas_en_riesgo |>
dplyr::filter(total>mean(total)) |> dplyr::select(claveseph,Nombre_d_1,LOCALIDAD,MUNICIPIO,total,geom) |>
dplyr::rename(riesgo_prioridad=total) |> st_zm()
escuelas_en_riesgo |>
dplyr::filter(total>mean(total)) |> dplyr::select(claveseph,Nombre_d_1,LOCALIDAD,MUNICIPIO,total,geom) |>
dplyr::rename(riesgo_prioridad=total) |> st_zm() |> st_write("../Inputs/PRIORIDAD_ESCUELAS.geojson",driver = "GeoJSON")
View(escuelas_en_riesgo)
shiny::runApp(appDir = "../")
View(Lista_BUIG)
Lista_BUIG[[213]]
st_read(buig,'inundacion')
buig <- DBI::dbConnect(
RPostgres::Postgres(),
dbname='geo_citnova',
host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com',
port = 5432,
user = 'geo_citnova',##geo_citnova es la que tiene permisos de admin
password = "Password2025"
)
st_read(buig,'inundacion')->inund
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = F,dTolerance = 20))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = F,dTolerance = 10))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 10))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 5))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 1))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 5))
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 5) |> st_make_valid())
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 5) |> st_make_valid() |> st_make_valid())
leaflet() |> addTiles() |> addPolygons(data=inund |> st_simplify(preserveTopology = T,dTolerance = 1) |> st_make_valid() |> st_make_valid())
inund |> st_simplify(preserveTopology = T,dTolerance = 1)
inund
shiny::runApp(appDir = "../")
shiny::runApp(appDir = "../")
